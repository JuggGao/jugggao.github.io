<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.78.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><style>a{text-decoration:none}</style><title>剑十三</title><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/index.xml title=剑十三></head><body><header><a style=font-size:24px;font-family:宋体;float:contour;font-weight:700 class=header-title href=https://jugggao.github.io/>剑十三</a><br><div style=float:right;font-size:15px;font-weight:700>与其感慨路难行，不如马上出发</div><br><a class=nav href=/>主页.</a>
<a class=nav href=/posts/>文档.</a>
<a class=nav href=/categories/>分类.</a>
<a class=nav href=/tags/>标签.</a>
<a class=nav href=/about/>关于.</a></nav></p></header><main><article class=border><h1><a href=https://jugggao.github.io/posts/jenkins/pipeline/jenkins-pipeline-%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AF%AD%E6%B3%95/>Jenkins Pipeline - 声明式语法</a></h1><b>时间：</b><time>16.11.2020</time> |
<b>分类：</b>
<a href=/categories/jenkins>Jenkins.</a>
|
<b>标签：</b>
<a href=/tags/jenkins>Jenkins.</a>
<a href=/tags/jenkins-pipeline>Jenkins Pipeline.</a><div><h3 id=jenkins-pipeline-声明式语法>Jenkins Pipeline 声明式语法</h3><p>Jenkins Pipeline 有两种语法风格：</p><ul><li>声明式管道语法（Declarative pipeline syntax）</li><li>脚本式管道语法（Scripted pipeline syntax）</li></ul><p>脚本式管道语法以 Groovy 语言为基础，语法结构同 Groovy 相同。
由于 Groovy 不适合所有初学者。所以 Jenkins 团队为编写 Jenkins 流水线提供一种更简单的声明式管道。</p><p>这两种语法的区别在于语法和灵活性：</p><ul><li>声明式管道语法鼓励采用<a href=https://en.wikipedia.org/wiki/Declarative_programming>声明式编程模型</a>；脚本式管道语法遵循<a href=https://en.wikipedia.org/wiki/Imperative_programming>命令式编程模型</a>。</li><li>声明式管道通过更严格和预定义的结构对用户施加了限制，这对于比较简单的持续交付流程来说是更理想的选择；而脚本式管道对于语法和结构唯一的限制是由 Groovy 子集本身定义的，脚本式管道几乎可以做任何事情，因此对于有更复杂的要求的用户或者对 Groovy 语言很熟练的用户来说是理想的选择。</li></ul><p><strong>关于如何选择声明式语法或者脚本式语法？</strong></p><ul><li>如果是 Jenkins 新手可以通过声明式管道语法入门，声明式管道提供了一些保护栏（框架），因此在刚开始学习的时候不会总出错，而且调试起来比较容易。另外，声明式管道的官方文档更详细。</li><li>如果是 Jenkins 高级用户或者对 Groovy 语言使用熟练，在工作中面对复杂的持续交付的场景，并且需要将逻辑复杂的管道代码模块化，那么脚本式管道结合共享库会更适合你。</li><li>如果是 Jenkins 管理员，则可能更希望坚持使用声明式管道，可以为使用者提供最佳的整体体验。并且能使其他的新同事更容易加入 Jenkins Pipeline 编写工作当中。</li></ul><p>总之，仁者见仁，智者见智。无论怎么选择，只需要确保<strong>一致性</strong>即可。</p><p>那就先从简单、易读的声明式语法说起。</p><a href=https://jugggao.github.io/posts/jenkins/pipeline/jenkins-pipeline-%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AF%AD%E6%B3%95/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-errors/>A Tour of Go - Exercise: Errors</a></h1><b>时间：</b><time>15.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-errorshttpstourgolangorgmethods20><a href=https://tour.golang.org/methods/20>Exercise: Errors</a></h3><p>Copy your Sqrt function from the <a href=https://tour.golang.org/flowcontrol/8>earlier exercise</a> and modify it to return an <code>error</code> value.</p><p><code>Sqrt</code> should return a non-nil error value when given a negative number, as it doesn&rsquo;t support complex numbers.</p><p>Create a new type</p><pre><code>type ErrNegativeSqrt float64
</code></pre><p>and make it an error by giving it a</p><pre><code>func (e ErrNegativeSqrt) Error() string
</code></pre><p>method such that <code>ErrNegativeSqrt(-2).Error()</code> returns <code>"cannot Sqrt negative number: -2"</code>.</p><p>Note: A call to <code>fmt.Sprint(e)</code> inside the <code>Error</code> method will send the program into an infinite loop. You can avoid this by converting e first: <code>fmt.Sprint(float64(e))</code>. Why?</p><p>Change your <code>Sqrt</code> function to return an <code>ErrNegativeSqrt</code> value when given a negative number.</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-errors/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-stringer/>A Tour of Go - Exercise: Stringers</a></h1><b>时间：</b><time>15.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-stringershttpstourgolangorgmethods18><a href=https://tour.golang.org/methods/18>Exercise: Stringers</a></h3><p>Make the <code>IPAddr</code> type implement <code>fmt.Stringer</code> to print the address as a dotted quad.</p><p>For instance, <code>IPAddr{1, 2, 3, 4}</code> should print as <code>"1.2.3.4"</code>.</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-stringer/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-fibonacci-closure/>A Tour of Go - Exercise: Fibonacci closure</a></h1><b>时间：</b><time>12.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-fibonacci-closurehttpstourgolangorgmoretypes26><a href=https://tour.golang.org/moretypes/26>Exercise: Fibonacci closure</a></h3><p>Let&rsquo;s have some fun with functions.</p><p>Implement a <code>fibonacci</code> function that returns a function (a closure) that returns successive <a href=https://en.wikipedia.org/wiki/Fibonacci_number>fibonacci numbers</a> (0, 1, 1, 2, 3, 5, &mldr;).</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-fibonacci-closure/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/jenkins/pipeline/groovy-%E7%9F%A5%E8%AF%86%E7%82%B9/>Jenkins Pipeline - Groovy 知识点</a></h1><b>时间：</b><time>12.11.2020</time> |
<b>分类：</b>
<a href=/categories/jenkins>Jenkins.</a>
|
<b>标签：</b>
<a href=/tags/jenkins>Jenkins.</a>
<a href=/tags/jenkins-pipeline>Jenkins Pipeline.</a>
<a href=/tags/groovy>Groovy.</a><div><h3 id=groovy-知识点>Groovy 知识点</h3><p>如果想深入学习 Jenkins，并编写 Jenkins Pipeline 共享库，Groovy 是必须学习并了的。<br>Groovy 是动态语言，语法和 Java 基本一致，实际上就是 Java，但是又有一些特性。<br>这里就记录自己需要注意的特性。</p><a href=https://jugggao.github.io/posts/jenkins/pipeline/groovy-%E7%9F%A5%E8%AF%86%E7%82%B9/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-maps/>A Tour of Go - Exercise: Maps</a></h1><b>时间：</b><time>11.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-mapshttpstourgolangorgmoretypes23><a href=https://tour.golang.org/moretypes/23>Exercise: Maps</a></h3><p>Implement <code>WordCount</code>. It should return a map of the counts of each “word” in the string <code>s</code>. The <code>wc.Test</code> function runs a test suite against the provided function and prints success or failure.</p><p>You might find <a href=https://golang.org/pkg/strings/#Fields>strings.Fields</a> helpful.</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-maps/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-slices/>A Tour of Go - Exercise: Slices</a></h1><b>时间：</b><time>10.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-sliceshttpstourgolangorgmoretypes18><a href=https://tour.golang.org/moretypes/18>Exercise: Slices</a></h3><p>Implement Pic. It should return a slice of length <code>dy</code>, each element of which is a slice of <code>dx</code> 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.</p><p>The choice of image is up to you. Interesting functions include <code>(x+y)/2</code>, <code>x*y</code>, and <code>x^y</code>.</p><p>(You need to use a loop to allocate each <code>[]uint8</code> inside the <code>[][]uint8</code>.)</p><p>(Use <code>uint8(intValue)</code> to convert between types.)</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-slices/>阅读全文...</a></div></article><br><br><article class=border><h1><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-loops-and-functions/>A Tour of Go - Exercise: Loops and Functions</a></h1><b>时间：</b><time>09.11.2020</time> |
<b>分类：</b>
<a href=/categories/go>Go.</a>
|
<b>标签：</b>
<a href=/tags/go>Go.</a>
<a href=/tags/a-tour-of-go>A Tour of Go.</a>
<a href=/tags/exercise>Exercise.</a><div><h3 id=exercise-loops-and-functionshttpstourgolangorgflowcontrol8><a href=https://tour.golang.org/flowcontrol/8>Exercise: Loops and Functions</a></h3><p>As a way to play with functions and loops, let&rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.</p><p>Computers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:</p><pre><code>z -= (z*z - x) / (2*z)
</code></pre><p>Repeating this adjustment makes the guess better and better until we reach an answer that is as close to the actual square root as can be.</p><p>Implement this in the <code>func Sqrt</code> provided. A decent starting guess for z is 1, no matter what the input. To begin with, repeat the calculation 10 times and print each z along the way. See how close you get to the answer for various values of x (1, 2, 3, &mldr;) and how quickly the guess improves.</p><p>Hint: To declare and initialize a floating point value, give it floating point syntax or use a conversion:</p><pre><code>z := 1.0
z := float64(1)
</code></pre><p>Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small amount). See if that&rsquo;s more or fewer than 10 iterations. Try other initial guesses for z, like x, or x/2. How close are your function&rsquo;s results to the <a href=https://golang.org/pkg/math/#Sqrt>math.Sqrt</a> in the standard library?</p><p>(Note: If you are interested in the details of the algorithm, the z² − x above is how far away z² is from where it needs to be (x), and the division by 2z is the derivative of z², to scale how much we adjust z by how quickly z² is changing. This general approach is called <a href=https://en.wikipedia.org/wiki/Newton%27s_method>Newton&rsquo;s method</a>. It works well for many functions but especially well for square root.)</p><a href=https://jugggao.github.io/posts/go/tour.golang.org/exercise-loops-and-functions/>阅读全文...</a></div></article><br><br><div>1 of 1</div></main><footer><p>&copy; 2020 <a href=https://jugggao.github.io/><b>剑十三.</b></a>
<a href=https://github.com/jugggao><b>Github.</b></a></p></footer></body></html>